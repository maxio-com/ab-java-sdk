/*
 * MaxioAdvancedBillingFormerlyChargifyAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.chargify.subdomain.controllers;

import com.chargify.subdomain.ApiHelper;
import com.chargify.subdomain.Server;
import com.chargify.subdomain.exceptions.ApiException;
import com.chargify.subdomain.exceptions.ErrorListResponseException;
import com.chargify.subdomain.exceptions.SubscriptionsInvoicesJson422ErrorException;
import com.chargify.subdomain.http.request.HttpMethod;
import com.chargify.subdomain.models.ConsolidatedInvoice;
import com.chargify.subdomain.models.CreateInvoicePaymentRequest;
import com.chargify.subdomain.models.CreateInvoiceRequest;
import com.chargify.subdomain.models.CreateMultiInvoicePaymentRequest;
import com.chargify.subdomain.models.CreditNote;
import com.chargify.subdomain.models.CustomerChangesPreviewResponse;
import com.chargify.subdomain.models.DirectionEnum;
import com.chargify.subdomain.models.Invoice;
import com.chargify.subdomain.models.InvoiceDateFieldEnum;
import com.chargify.subdomain.models.InvoiceEventTypeEnum;
import com.chargify.subdomain.models.InvoiceResponse;
import com.chargify.subdomain.models.InvoiceSortFieldEnum;
import com.chargify.subdomain.models.IssueInvoiceRequest;
import com.chargify.subdomain.models.ListCreditNotesResponse;
import com.chargify.subdomain.models.ListInvoiceEventsResponse;
import com.chargify.subdomain.models.ListInvoicesResponse;
import com.chargify.subdomain.models.MultiInvoicePaymentResponse;
import com.chargify.subdomain.models.PaymentResponse;
import com.chargify.subdomain.models.RecordPaymentRequest;
import com.chargify.subdomain.models.RefundInvoiceRequest;
import com.chargify.subdomain.models.SendInvoiceRequest;
import com.chargify.subdomain.models.StatusEnum;
import com.chargify.subdomain.models.VoidInvoiceRequest;
import com.fasterxml.jackson.core.JsonProcessingException;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class InvoicesController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public InvoicesController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Refund an invoice, segment, or consolidated invoice. ## Partial Refund for Consolidated
     * Invoice A refund less than the total of a consolidated invoice will be split across its
     * segments. A $50.00 refund on a $100.00 consolidated invoice with one $60.00 and one $40.00
     * segment, the refunded amount will be applied as 50% of each ($30.00 and $20.00 respectively).
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice refundInvoice(
            final String uid,
            final RefundInvoiceRequest body) throws ApiException, IOException {
        return prepareRefundInvoiceRequest(uid, body).execute();
    }

    /**
     * Refund an invoice, segment, or consolidated invoice. ## Partial Refund for Consolidated
     * Invoice A refund less than the total of a consolidated invoice will be split across its
     * segments. A $50.00 refund on a $100.00 consolidated invoice with one $60.00 and one $40.00
     * segment, the refunded amount will be applied as 50% of each ($30.00 and $20.00 respectively).
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> refundInvoiceAsync(
            final String uid,
            final RefundInvoiceRequest body) {
        try { 
            return prepareRefundInvoiceRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for refundInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareRefundInvoiceRequest(
            final String uid,
            final RefundInvoiceRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/refunds.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * By default, invoices returned on the index will only include totals, not detailed breakdowns
     * for `line_items`, `discounts`, `taxes`, `credits`, `payments`, `custom_fields`, or `refunds`.
     * To include breakdowns, pass the specific field as a key in the query with a value set to
     * `true`.
     * @param  startDate  Optional parameter: The start date (format YYYY-MM-DD) with which to
     *         filter the date_field. Returns invoices with a timestamp at or after midnight
     *         (12:00:00 AM) in your site’s time zone on the date specified.
     * @param  endDate  Optional parameter: The end date (format YYYY-MM-DD) with which to filter
     *         the date_field. Returns invoices with a timestamp up to and including 11:59:59PM in
     *         your site’s time zone on the date specified.
     * @param  status  Optional parameter: The current status of the invoice. Allowed Values: draft,
     *         open, paid, pending, voided
     * @param  subscriptionId  Optional parameter: The subscription's ID.
     * @param  subscriptionGroupUid  Optional parameter: The UID of the subscription group you want
     *         to fetch consolidated invoices for. This will return a paginated list of consolidated
     *         invoices for the specified group.
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  direction  Optional parameter: The sort direction of the returned invoices.
     * @param  lineItems  Optional parameter: Include line items data
     * @param  discounts  Optional parameter: Include discounts data
     * @param  taxes  Optional parameter: Include taxes data
     * @param  credits  Optional parameter: Include credits data
     * @param  payments  Optional parameter: Include payments data
     * @param  customFields  Optional parameter: Include custom fields data
     * @param  refunds  Optional parameter: Include refunds data
     * @param  dateField  Optional parameter: The type of filter you would like to apply to your
     *         search. Use in query `date_field=issue_date`.
     * @param  startDatetime  Optional parameter: The start date and time (format YYYY-MM-DD
     *         HH:MM:SS) with which to filter the date_field. Returns invoices with a timestamp at
     *         or after exact time provided in query. You can specify timezone in query - otherwise
     *         your site's time zone will be used. If provided, this parameter will be used instead
     *         of start_date. Allowed to be used only along with date_field set to created_at or
     *         updated_at.
     * @param  endDatetime  Optional parameter: The end date and time (format YYYY-MM-DD HH:MM:SS)
     *         with which to filter the date_field. Returns invoices with a timestamp at or before
     *         exact time provided in query. You can specify timezone in query - otherwise your
     *         site's time zone will be used. If provided, this parameter will be used instead of
     *         end_date. Allowed to be used only along with date_field set to created_at or
     *         updated_at.
     * @param  customerIds  Optional parameter: Allows fetching invoices with matching customer id
     *         based on provided values. Use in query `customer_ids=1,2,3`.
     * @param  number  Optional parameter: Allows fetching invoices with matching invoice number
     *         based on provided values. Use in query `number=1234,1235`.
     * @param  productIds  Optional parameter: Allows fetching invoices with matching line items
     *         product ids based on provided values. Use in query `product_ids=23,34`.
     * @param  sort  Optional parameter: Allows specification of the order of the returned list. Use
     *         in query `sort=total_amount`.
     * @return    Returns the ListInvoicesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ListInvoicesResponse listInvoices(
            final String startDate,
            final String endDate,
            final StatusEnum status,
            final Integer subscriptionId,
            final String subscriptionGroupUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean credits,
            final Boolean payments,
            final Boolean customFields,
            final Boolean refunds,
            final InvoiceDateFieldEnum dateField,
            final String startDatetime,
            final String endDatetime,
            final List<Object> customerIds,
            final List<String> number,
            final List<Integer> productIds,
            final InvoiceSortFieldEnum sort) throws ApiException, IOException {
        return prepareListInvoicesRequest(startDate, endDate, status, subscriptionId,
                subscriptionGroupUid, page, perPage, direction, lineItems, discounts, taxes,
                credits, payments, customFields, refunds, dateField, startDatetime, endDatetime,
                customerIds, number, productIds, sort).execute();
    }

    /**
     * By default, invoices returned on the index will only include totals, not detailed breakdowns
     * for `line_items`, `discounts`, `taxes`, `credits`, `payments`, `custom_fields`, or `refunds`.
     * To include breakdowns, pass the specific field as a key in the query with a value set to
     * `true`.
     * @param  startDate  Optional parameter: The start date (format YYYY-MM-DD) with which to
     *         filter the date_field. Returns invoices with a timestamp at or after midnight
     *         (12:00:00 AM) in your site’s time zone on the date specified.
     * @param  endDate  Optional parameter: The end date (format YYYY-MM-DD) with which to filter
     *         the date_field. Returns invoices with a timestamp up to and including 11:59:59PM in
     *         your site’s time zone on the date specified.
     * @param  status  Optional parameter: The current status of the invoice. Allowed Values: draft,
     *         open, paid, pending, voided
     * @param  subscriptionId  Optional parameter: The subscription's ID.
     * @param  subscriptionGroupUid  Optional parameter: The UID of the subscription group you want
     *         to fetch consolidated invoices for. This will return a paginated list of consolidated
     *         invoices for the specified group.
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  direction  Optional parameter: The sort direction of the returned invoices.
     * @param  lineItems  Optional parameter: Include line items data
     * @param  discounts  Optional parameter: Include discounts data
     * @param  taxes  Optional parameter: Include taxes data
     * @param  credits  Optional parameter: Include credits data
     * @param  payments  Optional parameter: Include payments data
     * @param  customFields  Optional parameter: Include custom fields data
     * @param  refunds  Optional parameter: Include refunds data
     * @param  dateField  Optional parameter: The type of filter you would like to apply to your
     *         search. Use in query `date_field=issue_date`.
     * @param  startDatetime  Optional parameter: The start date and time (format YYYY-MM-DD
     *         HH:MM:SS) with which to filter the date_field. Returns invoices with a timestamp at
     *         or after exact time provided in query. You can specify timezone in query - otherwise
     *         your site's time zone will be used. If provided, this parameter will be used instead
     *         of start_date. Allowed to be used only along with date_field set to created_at or
     *         updated_at.
     * @param  endDatetime  Optional parameter: The end date and time (format YYYY-MM-DD HH:MM:SS)
     *         with which to filter the date_field. Returns invoices with a timestamp at or before
     *         exact time provided in query. You can specify timezone in query - otherwise your
     *         site's time zone will be used. If provided, this parameter will be used instead of
     *         end_date. Allowed to be used only along with date_field set to created_at or
     *         updated_at.
     * @param  customerIds  Optional parameter: Allows fetching invoices with matching customer id
     *         based on provided values. Use in query `customer_ids=1,2,3`.
     * @param  number  Optional parameter: Allows fetching invoices with matching invoice number
     *         based on provided values. Use in query `number=1234,1235`.
     * @param  productIds  Optional parameter: Allows fetching invoices with matching line items
     *         product ids based on provided values. Use in query `product_ids=23,34`.
     * @param  sort  Optional parameter: Allows specification of the order of the returned list. Use
     *         in query `sort=total_amount`.
     * @return    Returns the ListInvoicesResponse response from the API call
     */
    public CompletableFuture<ListInvoicesResponse> listInvoicesAsync(
            final String startDate,
            final String endDate,
            final StatusEnum status,
            final Integer subscriptionId,
            final String subscriptionGroupUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean credits,
            final Boolean payments,
            final Boolean customFields,
            final Boolean refunds,
            final InvoiceDateFieldEnum dateField,
            final String startDatetime,
            final String endDatetime,
            final List<Object> customerIds,
            final List<String> number,
            final List<Integer> productIds,
            final InvoiceSortFieldEnum sort) {
        try { 
            return prepareListInvoicesRequest(startDate, endDate, status, subscriptionId,
            subscriptionGroupUid, page, perPage, direction, lineItems, discounts, taxes, credits,
            payments, customFields, refunds, dateField, startDatetime, endDatetime, customerIds,
            number, productIds, sort).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for listInvoices.
     */
    private ApiCall<ListInvoicesResponse, ApiException> prepareListInvoicesRequest(
            final String startDate,
            final String endDate,
            final StatusEnum status,
            final Integer subscriptionId,
            final String subscriptionGroupUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean credits,
            final Boolean payments,
            final Boolean customFields,
            final Boolean refunds,
            final InvoiceDateFieldEnum dateField,
            final String startDatetime,
            final String endDatetime,
            final List<Object> customerIds,
            final List<String> number,
            final List<Integer> productIds,
            final InvoiceSortFieldEnum sort) throws IOException {
        return new ApiCall.Builder<ListInvoicesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices.json")
                        .queryParam(param -> param.key("start_date")
                                .value(startDate).isRequired(false))
                        .queryParam(param -> param.key("end_date")
                                .value(endDate).isRequired(false))
                        .queryParam(param -> param.key("status")
                                .value((status != null) ? status.value() : null).isRequired(false))
                        .queryParam(param -> param.key("subscription_id")
                                .value(subscriptionId).isRequired(false))
                        .queryParam(param -> param.key("subscription_group_uid")
                                .value(subscriptionGroupUid).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 20).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : "desc").isRequired(false))
                        .queryParam(param -> param.key("line_items")
                                .value((lineItems != null) ? lineItems : false).isRequired(false))
                        .queryParam(param -> param.key("discounts")
                                .value((discounts != null) ? discounts : false).isRequired(false))
                        .queryParam(param -> param.key("taxes")
                                .value((taxes != null) ? taxes : false).isRequired(false))
                        .queryParam(param -> param.key("credits")
                                .value((credits != null) ? credits : false).isRequired(false))
                        .queryParam(param -> param.key("payments")
                                .value((payments != null) ? payments : false).isRequired(false))
                        .queryParam(param -> param.key("custom_fields")
                                .value((customFields != null) ? customFields : false).isRequired(false))
                        .queryParam(param -> param.key("refunds")
                                .value((refunds != null) ? refunds : false).isRequired(false))
                        .queryParam(param -> param.key("date_field")
                                .value((dateField != null) ? dateField.value() : "due_date").isRequired(false))
                        .queryParam(param -> param.key("start_datetime")
                                .value(startDatetime).isRequired(false))
                        .queryParam(param -> param.key("end_datetime")
                                .value(endDatetime).isRequired(false))
                        .queryParam(param -> param.key("customer_ids")
                                .value(customerIds).isRequired(false))
                        .queryParam(param -> param.key("number")
                                .value(number).isRequired(false))
                        .queryParam(param -> param.key("product_ids")
                                .value(productIds).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : "number").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ListInvoicesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to retrieve the details for an invoice.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice readInvoice(
            final String uid) throws ApiException, IOException {
        return prepareReadInvoiceRequest(uid).execute();
    }

    /**
     * Use this endpoint to retrieve the details for an invoice.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> readInvoiceAsync(
            final String uid) {
        try { 
            return prepareReadInvoiceRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for readInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareReadInvoiceRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint returns a list of invoice events. Each event contains event "data" (such as an
     * applied payment) as well as a snapshot of the `invoice` at the time of event completion.
     * Exposed event types are: + issue_invoice + apply_credit_note + apply_payment + refund_invoice
     * + void_invoice + void_remainder + backport_invoice + change_invoice_status +
     * change_invoice_collection_method + remove_payment Invoice events are returned in ascending
     * order. If both a `since_date` and `since_id` are provided in request parameters, the
     * `since_date` will be used. Note - invoice events that occurred prior to 09/05/2018 __will
     * not__ contain an `invoice` snapshot.
     * @param  sinceDate  Optional parameter: Example:
     * @param  sinceId  Optional parameter: Example:
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: Example: 100
     * @param  invoiceUid  Optional parameter: Providing an invoice_uid allows for scoping of the
     *         invoice events to a single invoice or credit note.
     * @param  withChangeInvoiceStatus  Optional parameter: Use this parameter if you want to fetch
     *         also invoice events with change_invoice_status type.
     * @param  eventTypes  Optional parameter: Filter results by event_type. Supply a comma
     *         separated list of event types (listed above). Use in query:
     *         `event_types=void_invoice,void_remainder`.
     * @return    Returns the ListInvoiceEventsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ListInvoiceEventsResponse listInvoiceEvents(
            final String sinceDate,
            final Integer sinceId,
            final Integer page,
            final Integer perPage,
            final String invoiceUid,
            final String withChangeInvoiceStatus,
            final List<InvoiceEventTypeEnum> eventTypes) throws ApiException, IOException {
        return prepareListInvoiceEventsRequest(sinceDate, sinceId, page, perPage, invoiceUid,
                withChangeInvoiceStatus, eventTypes).execute();
    }

    /**
     * This endpoint returns a list of invoice events. Each event contains event "data" (such as an
     * applied payment) as well as a snapshot of the `invoice` at the time of event completion.
     * Exposed event types are: + issue_invoice + apply_credit_note + apply_payment + refund_invoice
     * + void_invoice + void_remainder + backport_invoice + change_invoice_status +
     * change_invoice_collection_method + remove_payment Invoice events are returned in ascending
     * order. If both a `since_date` and `since_id` are provided in request parameters, the
     * `since_date` will be used. Note - invoice events that occurred prior to 09/05/2018 __will
     * not__ contain an `invoice` snapshot.
     * @param  sinceDate  Optional parameter: Example:
     * @param  sinceId  Optional parameter: Example:
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: Example: 100
     * @param  invoiceUid  Optional parameter: Providing an invoice_uid allows for scoping of the
     *         invoice events to a single invoice or credit note.
     * @param  withChangeInvoiceStatus  Optional parameter: Use this parameter if you want to fetch
     *         also invoice events with change_invoice_status type.
     * @param  eventTypes  Optional parameter: Filter results by event_type. Supply a comma
     *         separated list of event types (listed above). Use in query:
     *         `event_types=void_invoice,void_remainder`.
     * @return    Returns the ListInvoiceEventsResponse response from the API call
     */
    public CompletableFuture<ListInvoiceEventsResponse> listInvoiceEventsAsync(
            final String sinceDate,
            final Integer sinceId,
            final Integer page,
            final Integer perPage,
            final String invoiceUid,
            final String withChangeInvoiceStatus,
            final List<InvoiceEventTypeEnum> eventTypes) {
        try { 
            return prepareListInvoiceEventsRequest(sinceDate, sinceId, page, perPage, invoiceUid,
            withChangeInvoiceStatus, eventTypes).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for listInvoiceEvents.
     */
    private ApiCall<ListInvoiceEventsResponse, ApiException> prepareListInvoiceEventsRequest(
            final String sinceDate,
            final Integer sinceId,
            final Integer page,
            final Integer perPage,
            final String invoiceUid,
            final String withChangeInvoiceStatus,
            final List<InvoiceEventTypeEnum> eventTypes) throws IOException {
        return new ApiCall.Builder<ListInvoiceEventsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/events.json")
                        .queryParam(param -> param.key("since_date")
                                .value(sinceDate).isRequired(false))
                        .queryParam(param -> param.key("since_id")
                                .value(sinceId).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 100).isRequired(false))
                        .queryParam(param -> param.key("invoice_uid")
                                .value(invoiceUid).isRequired(false))
                        .queryParam(param -> param.key("with_change_invoice_status")
                                .value(withChangeInvoiceStatus).isRequired(false))
                        .queryParam(param -> param.key("event_types")
                                .value(InvoiceEventTypeEnum.toValue(eventTypes)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ListInvoiceEventsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API call should be used when you want to record a payment of a given type against a
     * specific invoice. If you would like to apply a payment across multiple invoices, you can use
     * the Bulk Payment endpoint. ## Create a Payment from the existing payment profile In order to
     * apply a payment to an invoice using an existing payment profile, specify `type` as `payment`,
     * the amount less than the invoice total, and the customer's `payment_profile_id`. The ID of a
     * payment profile might be retrieved via the Payment Profiles API endpoint. ``` { "type":
     * "payment", "payment": { "amount": 10.00, "payment_profile_id": 123 } } ``` ## Create a
     * Payment from the Subscription's Prepayment Account In order apply a prepayment to an invoice,
     * specify the `type` as `prepayment`, and also the `amount`. ``` { "type": "prepayment",
     * "payment": { "amount": 10.00 } } ``` Note that the `amount` must be less than or equal to the
     * Subscription's Prepayment account balance. ## Create a Payment from the Subscription's
     * Service Credit Account In order to apply a service credit to an invoice, specify the `type`
     * as `service_credit`, and also the `amount`: ``` { "type": "service_credit", "payment": {
     * "amount": 10.00 } } ``` Note that Chargify will attempt to fully pay the invoice's
     * `due_amount` from the Subscription's Service Credit account. At this time, partial payments
     * from a Service Credit Account are only allowed for consolidated invoices (subscription
     * groups). Therefore, for normal invoices the Service Credit account balance must be greater
     * than or equal to the invoice's `due_amount`.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice recordPaymentForInvoice(
            final String uid,
            final CreateInvoicePaymentRequest body) throws ApiException, IOException {
        return prepareRecordPaymentForInvoiceRequest(uid, body).execute();
    }

    /**
     * This API call should be used when you want to record a payment of a given type against a
     * specific invoice. If you would like to apply a payment across multiple invoices, you can use
     * the Bulk Payment endpoint. ## Create a Payment from the existing payment profile In order to
     * apply a payment to an invoice using an existing payment profile, specify `type` as `payment`,
     * the amount less than the invoice total, and the customer's `payment_profile_id`. The ID of a
     * payment profile might be retrieved via the Payment Profiles API endpoint. ``` { "type":
     * "payment", "payment": { "amount": 10.00, "payment_profile_id": 123 } } ``` ## Create a
     * Payment from the Subscription's Prepayment Account In order apply a prepayment to an invoice,
     * specify the `type` as `prepayment`, and also the `amount`. ``` { "type": "prepayment",
     * "payment": { "amount": 10.00 } } ``` Note that the `amount` must be less than or equal to the
     * Subscription's Prepayment account balance. ## Create a Payment from the Subscription's
     * Service Credit Account In order to apply a service credit to an invoice, specify the `type`
     * as `service_credit`, and also the `amount`: ``` { "type": "service_credit", "payment": {
     * "amount": 10.00 } } ``` Note that Chargify will attempt to fully pay the invoice's
     * `due_amount` from the Subscription's Service Credit account. At this time, partial payments
     * from a Service Credit Account are only allowed for consolidated invoices (subscription
     * groups). Therefore, for normal invoices the Service Credit account balance must be greater
     * than or equal to the invoice's `due_amount`.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> recordPaymentForInvoiceAsync(
            final String uid,
            final CreateInvoicePaymentRequest body) {
        try { 
            return prepareRecordPaymentForInvoiceRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for recordPaymentForInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareRecordPaymentForInvoiceRequest(
            final String uid,
            final CreateInvoicePaymentRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/payments.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API call should be used when you want to record an external payment against multiple
     * invoices. In order apply a payment to multiple invoices, at minimum, specify the `amount` and
     * `applications` (i.e., `invoice_uid` and `amount`) details. ``` { "payment": { "memo": "to pay
     * the bills", "details": "check number 8675309", "method": "check", "amount": "250.00",
     * "applications": [ { "invoice_uid": "inv_8gk5bwkct3gqt", "amount": "100.00" }, {
     * "invoice_uid": "inv_7bc6bwkct3lyt", "amount": "150.00" } ] } } ``` Note that the invoice
     * payment amounts must be greater than 0. Total amount must be greater or equal to invoices
     * payment amount sum.
     * @param  body  Optional parameter: Example:
     * @return    Returns the MultiInvoicePaymentResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public MultiInvoicePaymentResponse recordExternalPaymentForInvoices(
            final CreateMultiInvoicePaymentRequest body) throws ApiException, IOException {
        return prepareRecordExternalPaymentForInvoicesRequest(body).execute();
    }

    /**
     * This API call should be used when you want to record an external payment against multiple
     * invoices. In order apply a payment to multiple invoices, at minimum, specify the `amount` and
     * `applications` (i.e., `invoice_uid` and `amount`) details. ``` { "payment": { "memo": "to pay
     * the bills", "details": "check number 8675309", "method": "check", "amount": "250.00",
     * "applications": [ { "invoice_uid": "inv_8gk5bwkct3gqt", "amount": "100.00" }, {
     * "invoice_uid": "inv_7bc6bwkct3lyt", "amount": "150.00" } ] } } ``` Note that the invoice
     * payment amounts must be greater than 0. Total amount must be greater or equal to invoices
     * payment amount sum.
     * @param  body  Optional parameter: Example:
     * @return    Returns the MultiInvoicePaymentResponse response from the API call
     */
    public CompletableFuture<MultiInvoicePaymentResponse> recordExternalPaymentForInvoicesAsync(
            final CreateMultiInvoicePaymentRequest body) {
        try { 
            return prepareRecordExternalPaymentForInvoicesRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for recordExternalPaymentForInvoices.
     */
    private ApiCall<MultiInvoicePaymentResponse, ApiException> prepareRecordExternalPaymentForInvoicesRequest(
            final CreateMultiInvoicePaymentRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<MultiInvoicePaymentResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/payments.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, MultiInvoicePaymentResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Credit Notes are like inverse invoices. They reduce the amount a customer owes. By default,
     * the credit notes returned by this endpoint will exclude the arrays of `line_items`,
     * `discounts`, `taxes`, `applications`, or `refunds`. To include these arrays, pass the
     * specific field as a key in the query with a value set to `true`.
     * @param  subscriptionId  Optional parameter: The subscription's Chargify id
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  lineItems  Optional parameter: Include line items data
     * @param  discounts  Optional parameter: Include discounts data
     * @param  taxes  Optional parameter: Include taxes data
     * @param  refunds  Optional parameter: Include refunds data
     * @param  applications  Optional parameter: Include applications data
     * @return    Returns the ListCreditNotesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ListCreditNotesResponse listCreditNotes(
            final Integer subscriptionId,
            final Integer page,
            final Integer perPage,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean refunds,
            final Boolean applications) throws ApiException, IOException {
        return prepareListCreditNotesRequest(subscriptionId, page, perPage, lineItems, discounts,
                taxes, refunds, applications).execute();
    }

    /**
     * Credit Notes are like inverse invoices. They reduce the amount a customer owes. By default,
     * the credit notes returned by this endpoint will exclude the arrays of `line_items`,
     * `discounts`, `taxes`, `applications`, or `refunds`. To include these arrays, pass the
     * specific field as a key in the query with a value set to `true`.
     * @param  subscriptionId  Optional parameter: The subscription's Chargify id
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  lineItems  Optional parameter: Include line items data
     * @param  discounts  Optional parameter: Include discounts data
     * @param  taxes  Optional parameter: Include taxes data
     * @param  refunds  Optional parameter: Include refunds data
     * @param  applications  Optional parameter: Include applications data
     * @return    Returns the ListCreditNotesResponse response from the API call
     */
    public CompletableFuture<ListCreditNotesResponse> listCreditNotesAsync(
            final Integer subscriptionId,
            final Integer page,
            final Integer perPage,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean refunds,
            final Boolean applications) {
        try { 
            return prepareListCreditNotesRequest(subscriptionId, page, perPage, lineItems, discounts, taxes,
            refunds, applications).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for listCreditNotes.
     */
    private ApiCall<ListCreditNotesResponse, ApiException> prepareListCreditNotesRequest(
            final Integer subscriptionId,
            final Integer page,
            final Integer perPage,
            final Boolean lineItems,
            final Boolean discounts,
            final Boolean taxes,
            final Boolean refunds,
            final Boolean applications) throws IOException {
        return new ApiCall.Builder<ListCreditNotesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/credit_notes.json")
                        .queryParam(param -> param.key("subscription_id")
                                .value(subscriptionId).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 20).isRequired(false))
                        .queryParam(param -> param.key("line_items")
                                .value((lineItems != null) ? lineItems : false).isRequired(false))
                        .queryParam(param -> param.key("discounts")
                                .value((discounts != null) ? discounts : false).isRequired(false))
                        .queryParam(param -> param.key("taxes")
                                .value((taxes != null) ? taxes : false).isRequired(false))
                        .queryParam(param -> param.key("refunds")
                                .value((refunds != null) ? refunds : false).isRequired(false))
                        .queryParam(param -> param.key("applications")
                                .value((applications != null) ? applications : false).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ListCreditNotesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to retrieve the details for a credit note.
     * @param  uid  Required parameter: The unique identifier of the credit note
     * @return    Returns the CreditNote response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CreditNote readCreditNote(
            final String uid) throws ApiException, IOException {
        return prepareReadCreditNoteRequest(uid).execute();
    }

    /**
     * Use this endpoint to retrieve the details for a credit note.
     * @param  uid  Required parameter: The unique identifier of the credit note
     * @return    Returns the CreditNote response from the API call
     */
    public CompletableFuture<CreditNote> readCreditNoteAsync(
            final String uid) {
        try { 
            return prepareReadCreditNoteRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for readCreditNote.
     */
    private ApiCall<CreditNote, ApiException> prepareReadCreditNoteRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<CreditNote, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/credit_notes/{uid}.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CreditNote.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Record an external payment made against a subscription that will pay partially or in full one
     * or more invoices. Payment will be applied starting with the oldest open invoice and then next
     * oldest, and so on until the amount of the payment is fully consumed. Excess payment will
     * result in the creation of a prepayment on the Invoice Account. Only ungrouped or primary
     * subscriptions may be paid using the "bulk" payment request.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the PaymentResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PaymentResponse recordPaymentForSubscription(
            final String subscriptionId,
            final RecordPaymentRequest body) throws ApiException, IOException {
        return prepareRecordPaymentForSubscriptionRequest(subscriptionId, body).execute();
    }

    /**
     * Record an external payment made against a subscription that will pay partially or in full one
     * or more invoices. Payment will be applied starting with the oldest open invoice and then next
     * oldest, and so on until the amount of the payment is fully consumed. Excess payment will
     * result in the creation of a prepayment on the Invoice Account. Only ungrouped or primary
     * subscriptions may be paid using the "bulk" payment request.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the PaymentResponse response from the API call
     */
    public CompletableFuture<PaymentResponse> recordPaymentForSubscriptionAsync(
            final String subscriptionId,
            final RecordPaymentRequest body) {
        try { 
            return prepareRecordPaymentForSubscriptionRequest(subscriptionId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for recordPaymentForSubscription.
     */
    private ApiCall<PaymentResponse, ApiException> prepareRecordPaymentForSubscriptionRequest(
            final String subscriptionId,
            final RecordPaymentRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PaymentResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscriptions/{subscription_id}/payments.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("subscription_id").value(subscriptionId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PaymentResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint allows you to reopen any invoice with the "canceled" status. Invoices enter
     * "canceled" status if they were open at the time the subscription was canceled (whether
     * through dunning or an intentional cancellation). Invoices with "canceled" status are no
     * longer considered to be due. Once reopened, they are considered due for payment. Payment may
     * then be captured in one of the following ways: - Reactivating the subscription, which will
     * capture all open invoices (See note below about automatic reopening of invoices.) - Recording
     * a payment directly against the invoice A note about reactivations: any canceled invoices from
     * the most recent active period are automatically opened as a part of the reactivation process.
     * Reactivating via this endpoint prior to reactivation is only necessary when you wish to
     * capture older invoices from previous periods during the reactivation. ### Reopening
     * Consolidated Invoices When reopening a consolidated invoice, all of its canceled segments
     * will also be reopened.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice reopenInvoice(
            final String uid) throws ApiException, IOException {
        return prepareReopenInvoiceRequest(uid).execute();
    }

    /**
     * This endpoint allows you to reopen any invoice with the "canceled" status. Invoices enter
     * "canceled" status if they were open at the time the subscription was canceled (whether
     * through dunning or an intentional cancellation). Invoices with "canceled" status are no
     * longer considered to be due. Once reopened, they are considered due for payment. Payment may
     * then be captured in one of the following ways: - Reactivating the subscription, which will
     * capture all open invoices (See note below about automatic reopening of invoices.) - Recording
     * a payment directly against the invoice A note about reactivations: any canceled invoices from
     * the most recent active period are automatically opened as a part of the reactivation process.
     * Reactivating via this endpoint prior to reactivation is only necessary when you wish to
     * capture older invoices from previous periods during the reactivation. ### Reopening
     * Consolidated Invoices When reopening a consolidated invoice, all of its canceled segments
     * will also be reopened.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> reopenInvoiceAsync(
            final String uid) {
        try { 
            return prepareReopenInvoiceRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reopenInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareReopenInvoiceRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/reopen.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint allows you to void any invoice with the "open" or "canceled" status. It will
     * also allow voiding of an invoice with the "pending" status if it is not a consolidated
     * invoice.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice voidInvoice(
            final String uid,
            final VoidInvoiceRequest body) throws ApiException, IOException {
        return prepareVoidInvoiceRequest(uid, body).execute();
    }

    /**
     * This endpoint allows you to void any invoice with the "open" or "canceled" status. It will
     * also allow voiding of an invoice with the "pending" status if it is not a consolidated
     * invoice.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> voidInvoiceAsync(
            final String uid,
            final VoidInvoiceRequest body) {
        try { 
            return prepareVoidInvoiceRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for voidInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareVoidInvoiceRequest(
            final String uid,
            final VoidInvoiceRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/void.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Invoice segments returned on the index will only include totals, not detailed breakdowns for
     * `line_items`, `discounts`, `taxes`, `credits`, `payments`, or `custom_fields`.
     * @param  invoiceUid  Required parameter: The unique identifier of the consolidated invoice
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  direction  Optional parameter: Sort direction of the returned segments.
     * @return    Returns the ConsolidatedInvoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ConsolidatedInvoice listInvoiceSegments(
            final String invoiceUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction) throws ApiException, IOException {
        return prepareListInvoiceSegmentsRequest(invoiceUid, page, perPage, direction).execute();
    }

    /**
     * Invoice segments returned on the index will only include totals, not detailed breakdowns for
     * `line_items`, `discounts`, `taxes`, `credits`, `payments`, or `custom_fields`.
     * @param  invoiceUid  Required parameter: The unique identifier of the consolidated invoice
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  direction  Optional parameter: Sort direction of the returned segments.
     * @return    Returns the ConsolidatedInvoice response from the API call
     */
    public CompletableFuture<ConsolidatedInvoice> listInvoiceSegmentsAsync(
            final String invoiceUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction) {
        try { 
            return prepareListInvoiceSegmentsRequest(invoiceUid, page, perPage, direction).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for listInvoiceSegments.
     */
    private ApiCall<ConsolidatedInvoice, ApiException> prepareListInvoiceSegmentsRequest(
            final String invoiceUid,
            final Integer page,
            final Integer perPage,
            final DirectionEnum direction) throws IOException {
        return new ApiCall.Builder<ConsolidatedInvoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{invoice_uid}/segments.json")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 20).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : "asc").isRequired(false))
                        .templateParam(param -> param.key("invoice_uid").value(invoiceUid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ConsolidatedInvoice.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint will allow you to create an ad hoc invoice. ### Basic Behavior You can create a
     * basic invoice by sending an array of line items to this endpoint. Each line item, at a
     * minimum, must include a title, a quantity and a unit price. Example: ```json { "invoice": {
     * "line_items": [ { "title": "A Product", "quantity": 12, "unit_price": "150.00" } ] } } ```
     * ### Catalog items Instead of creating custom products like in above example, You can pass
     * existing items like products, components. ```json { "invoice": { "line_items": [ {
     * "product_id": "handle:gold-product", "quantity": 2, } ] } } ``` The price for each line item
     * will be calculated as well as a total due amount for the invoice. Multiple line items can be
     * sent. ### Line items types When defining line item, You can choose one of 3 types for one
     * line item: #### Custom item Like in basic behavior example above, You can pass `title` and
     * `unit_price` for custom item. #### Product id Product handle (with handle: prefix) or id from
     * the scope of current subscription's site can be provided with `product_id`. By default
     * `unit_price` is taken from product's default price point, but can be overwritten by passing
     * `unit_price` or `product_price_point_id`. If `product_id` is used, following fields cannot be
     * used: `title`, `component_id`. #### Component id Component handle (with handle: prefix) or id
     * from the scope of current subscription's site can be provided with `component_id`. If
     * `component_id` is used, following fields cannot be used: `title`, `product_id`. By default
     * `unit_price` is taken from product's default price point, but can be overwritten by passing
     * `unit_price` or `price_point_id`. At this moment price points are supportted only for
     * quantity based, on/off and metered components. For prepaid and event based billing components
     * `unit_price` is required. ### Coupons When creating ad hoc invoice, new discounts can be
     * applied in following way: ```json { "invoice": { "line_items": [ { "product_id":
     * "handle:gold-product", "quantity": 1 } ], "coupons": [ { "code": "COUPONCODE", "percentage":
     * 50.0 } ] } } ``` If You want to use existing coupon for discount creation, only `code` and
     * optional `product_family_id` is needed ```json ... "coupons": [ { "code": "FREESETUP",
     * "product_family_id": 1 } ] ... ``` ### Coupon options #### Code Coupon `code` will be
     * displayed on invoice discount section. Coupon code can only contain uppercase letters,
     * numbers, and allowed special characters. Lowercase letters will be converted to uppercase. It
     * can be used to select an existing coupon from the catalog, or as an ad hoc coupon when passed
     * with `percentage` or `amount`. #### Percentage Coupon `percentage` can take values from 0 to
     * 100 and up to 4 decimal places. It cannot be used with `amount`. Only for ad hoc coupons,
     * will be ignored if `code` is used to select an existing coupon from the catalog. #### Amount
     * Coupon `amount` takes number value. It cannot be used with `percentage`. Used only when not
     * matching existing coupon by `code`. #### Description Optional `description` will be displayed
     * with coupon `code`. Used only when not matching existing coupon by `code`. #### Product
     * Family id Optional `product_family_id` handle (with handle: prefix) or id is used to match
     * existing coupon within site, when codes are not unique. #### Compounding Strategy Optional
     * `compounding_strategy` for percentage coupons, can take values `compound` or `full-price`.
     * For amount coupons, discounts will be always calculated against the original item price,
     * before other discounts are applied. `compound` strategy: Percentage-based discounts will be
     * calculated against the remaining price, after prior discounts have been calculated. It is set
     * by default. `full-price` strategy: Percentage-based discounts will always be calculated
     * against the original item price, before other discounts are applied. ### Line Item Options
     * #### Period Date Range A custom period date range can be defined for each line item with the
     * `period_range_start` and `period_range_end` parameters. Dates must be sent in the
     * `YYYY-MM-DD` format. `period_range_end` must be greater or equal `period_range_start`. ####
     * Taxes The `taxable` parameter can be sent as `true` if taxes should be calculated for a
     * specific line item. For this to work, the site should be configured to use and calculate
     * taxes. Further, if the site uses Avalara for tax calculations, a `tax_code` parameter should
     * also be sent. For existing catalog items: products/components taxes cannot be overwritten.
     * #### Price Point Price point handle (with handle: prefix) or id from the scope of current
     * subscription's site can be provided with `price_point_id` for components with `component_id`
     * or `product_price_point_id` for products with `product_id` parameter. If price point is
     * passed `unit_price` cannot be used. It can be used only with catalog items products and
     * components. #### Description Optional `description` parameter, it will overwrite default
     * generated description for line item. ### Invoice Options #### Issue Date By default, invoices
     * will be created with a issue date set to today. `issue_date` parameter can be send to alter
     * that. Only dates in the past can be send. `issue_date` should be send in `YYYY-MM-DD` format.
     * #### Net Terms By default, invoices will be created with a due date matching the date of
     * invoice creation. If a different due date is desired, the `net_terms` parameter can be sent
     * indicating the number of days in advance the due date should be. #### Addresses The seller,
     * shipping and billing addresses can be sent to override the site's defaults. Each address
     * requires to send a `first_name` at a minimum in order to work. Please see below for the
     * details on which parameters can be sent for each address object. #### Memo and Payment
     * Instructions A custom memo can be sent with the `memo` parameter to override the site's
     * default. Likewise, custom payment instructions can be sent with the `payment_instrucions`
     * parameter. #### Status By default, invoices will be created with open status. Possible
     * alternative is `draft`.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the InvoiceResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InvoiceResponse createInvoice(
            final String subscriptionId,
            final CreateInvoiceRequest body) throws ApiException, IOException {
        return prepareCreateInvoiceRequest(subscriptionId, body).execute();
    }

    /**
     * This endpoint will allow you to create an ad hoc invoice. ### Basic Behavior You can create a
     * basic invoice by sending an array of line items to this endpoint. Each line item, at a
     * minimum, must include a title, a quantity and a unit price. Example: ```json { "invoice": {
     * "line_items": [ { "title": "A Product", "quantity": 12, "unit_price": "150.00" } ] } } ```
     * ### Catalog items Instead of creating custom products like in above example, You can pass
     * existing items like products, components. ```json { "invoice": { "line_items": [ {
     * "product_id": "handle:gold-product", "quantity": 2, } ] } } ``` The price for each line item
     * will be calculated as well as a total due amount for the invoice. Multiple line items can be
     * sent. ### Line items types When defining line item, You can choose one of 3 types for one
     * line item: #### Custom item Like in basic behavior example above, You can pass `title` and
     * `unit_price` for custom item. #### Product id Product handle (with handle: prefix) or id from
     * the scope of current subscription's site can be provided with `product_id`. By default
     * `unit_price` is taken from product's default price point, but can be overwritten by passing
     * `unit_price` or `product_price_point_id`. If `product_id` is used, following fields cannot be
     * used: `title`, `component_id`. #### Component id Component handle (with handle: prefix) or id
     * from the scope of current subscription's site can be provided with `component_id`. If
     * `component_id` is used, following fields cannot be used: `title`, `product_id`. By default
     * `unit_price` is taken from product's default price point, but can be overwritten by passing
     * `unit_price` or `price_point_id`. At this moment price points are supportted only for
     * quantity based, on/off and metered components. For prepaid and event based billing components
     * `unit_price` is required. ### Coupons When creating ad hoc invoice, new discounts can be
     * applied in following way: ```json { "invoice": { "line_items": [ { "product_id":
     * "handle:gold-product", "quantity": 1 } ], "coupons": [ { "code": "COUPONCODE", "percentage":
     * 50.0 } ] } } ``` If You want to use existing coupon for discount creation, only `code` and
     * optional `product_family_id` is needed ```json ... "coupons": [ { "code": "FREESETUP",
     * "product_family_id": 1 } ] ... ``` ### Coupon options #### Code Coupon `code` will be
     * displayed on invoice discount section. Coupon code can only contain uppercase letters,
     * numbers, and allowed special characters. Lowercase letters will be converted to uppercase. It
     * can be used to select an existing coupon from the catalog, or as an ad hoc coupon when passed
     * with `percentage` or `amount`. #### Percentage Coupon `percentage` can take values from 0 to
     * 100 and up to 4 decimal places. It cannot be used with `amount`. Only for ad hoc coupons,
     * will be ignored if `code` is used to select an existing coupon from the catalog. #### Amount
     * Coupon `amount` takes number value. It cannot be used with `percentage`. Used only when not
     * matching existing coupon by `code`. #### Description Optional `description` will be displayed
     * with coupon `code`. Used only when not matching existing coupon by `code`. #### Product
     * Family id Optional `product_family_id` handle (with handle: prefix) or id is used to match
     * existing coupon within site, when codes are not unique. #### Compounding Strategy Optional
     * `compounding_strategy` for percentage coupons, can take values `compound` or `full-price`.
     * For amount coupons, discounts will be always calculated against the original item price,
     * before other discounts are applied. `compound` strategy: Percentage-based discounts will be
     * calculated against the remaining price, after prior discounts have been calculated. It is set
     * by default. `full-price` strategy: Percentage-based discounts will always be calculated
     * against the original item price, before other discounts are applied. ### Line Item Options
     * #### Period Date Range A custom period date range can be defined for each line item with the
     * `period_range_start` and `period_range_end` parameters. Dates must be sent in the
     * `YYYY-MM-DD` format. `period_range_end` must be greater or equal `period_range_start`. ####
     * Taxes The `taxable` parameter can be sent as `true` if taxes should be calculated for a
     * specific line item. For this to work, the site should be configured to use and calculate
     * taxes. Further, if the site uses Avalara for tax calculations, a `tax_code` parameter should
     * also be sent. For existing catalog items: products/components taxes cannot be overwritten.
     * #### Price Point Price point handle (with handle: prefix) or id from the scope of current
     * subscription's site can be provided with `price_point_id` for components with `component_id`
     * or `product_price_point_id` for products with `product_id` parameter. If price point is
     * passed `unit_price` cannot be used. It can be used only with catalog items products and
     * components. #### Description Optional `description` parameter, it will overwrite default
     * generated description for line item. ### Invoice Options #### Issue Date By default, invoices
     * will be created with a issue date set to today. `issue_date` parameter can be send to alter
     * that. Only dates in the past can be send. `issue_date` should be send in `YYYY-MM-DD` format.
     * #### Net Terms By default, invoices will be created with a due date matching the date of
     * invoice creation. If a different due date is desired, the `net_terms` parameter can be sent
     * indicating the number of days in advance the due date should be. #### Addresses The seller,
     * shipping and billing addresses can be sent to override the site's defaults. Each address
     * requires to send a `first_name` at a minimum in order to work. Please see below for the
     * details on which parameters can be sent for each address object. #### Memo and Payment
     * Instructions A custom memo can be sent with the `memo` parameter to override the site's
     * default. Likewise, custom payment instructions can be sent with the `payment_instrucions`
     * parameter. #### Status By default, invoices will be created with open status. Possible
     * alternative is `draft`.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the InvoiceResponse response from the API call
     */
    public CompletableFuture<InvoiceResponse> createInvoiceAsync(
            final String subscriptionId,
            final CreateInvoiceRequest body) {
        try { 
            return prepareCreateInvoiceRequest(subscriptionId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for createInvoice.
     */
    private ApiCall<InvoiceResponse, ApiException> prepareCreateInvoiceRequest(
            final String subscriptionId,
            final CreateInvoiceRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InvoiceResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscriptions/{subscription_id}/invoices.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("subscription_id").value(subscriptionId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InvoiceResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new SubscriptionsInvoicesJson422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint allows for invoices to be programmatically delivered via email. This endpoint
     * supports the delivery of both ad-hoc and automatically generated invoices. Additionally, this
     * endpoint supports email delivery to direct recipients, carbon-copy (cc) recipients, and blind
     * carbon-copy (bcc) recipients. Please note that if no recipient email addresses are specified
     * in the request, then the subscription's default email configuration will be used. For
     * example, if `recipient_emails` is left blank, then the invoice will be delivered to the
     * subscription's customer email address. On success, a 204 no-content response will be
     * returned. Please note that this does not indicate that email(s) have been delivered, but
     * instead indicates that emails have been successfully queued for delivery. If _any_ invalid or
     * malformed email address is found in the request body, the entire request will be rejected and
     * a 422 response will be returned.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void sendInvoice(
            final String uid,
            final SendInvoiceRequest body) throws ApiException, IOException {
        prepareSendInvoiceRequest(uid, body).execute();
    }

    /**
     * This endpoint allows for invoices to be programmatically delivered via email. This endpoint
     * supports the delivery of both ad-hoc and automatically generated invoices. Additionally, this
     * endpoint supports email delivery to direct recipients, carbon-copy (cc) recipients, and blind
     * carbon-copy (bcc) recipients. Please note that if no recipient email addresses are specified
     * in the request, then the subscription's default email configuration will be used. For
     * example, if `recipient_emails` is left blank, then the invoice will be delivered to the
     * subscription's customer email address. On success, a 204 no-content response will be
     * returned. Please note that this does not indicate that email(s) have been delivered, but
     * instead indicates that emails have been successfully queued for delivery. If _any_ invalid or
     * malformed email address is found in the request body, the entire request will be rejected and
     * a 422 response will be returned.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> sendInvoiceAsync(
            final String uid,
            final SendInvoiceRequest body) {
        try { 
            return prepareSendInvoiceRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for sendInvoice.
     */
    private ApiCall<Void, ApiException> prepareSendInvoiceRequest(
            final String uid,
            final SendInvoiceRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/deliveries.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Customer information may change after an invoice is issued which may lead to a mismatch
     * between customer information that are present on an open invoice and actual customer
     * information. This endpoint allows to preview these differences, if any. The endpoint doesn't
     * accept a request body. Customer information differences are calculated on the application
     * side.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the CustomerChangesPreviewResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CustomerChangesPreviewResponse previewCustomerInformationChanges(
            final String uid) throws ApiException, IOException {
        return preparePreviewCustomerInformationChangesRequest(uid).execute();
    }

    /**
     * Customer information may change after an invoice is issued which may lead to a mismatch
     * between customer information that are present on an open invoice and actual customer
     * information. This endpoint allows to preview these differences, if any. The endpoint doesn't
     * accept a request body. Customer information differences are calculated on the application
     * side.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the CustomerChangesPreviewResponse response from the API call
     */
    public CompletableFuture<CustomerChangesPreviewResponse> previewCustomerInformationChangesAsync(
            final String uid) {
        try { 
            return preparePreviewCustomerInformationChangesRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for previewCustomerInformationChanges.
     */
    private ApiCall<CustomerChangesPreviewResponse, ApiException> preparePreviewCustomerInformationChangesRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<CustomerChangesPreviewResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/customer_information/preview.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CustomerChangesPreviewResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint updates customer information on an open invoice and returns the updated
     * invoice. If you would like to preview changes that will be applied, use the
     * `/invoices/{uid}/customer_information/preview.json` endpoint before. The endpoint doesn't
     * accept a request body. Customer information differences are calculated on the application
     * side.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice updateCustomerInformation(
            final String uid) throws ApiException, IOException {
        return prepareUpdateCustomerInformationRequest(uid).execute();
    }

    /**
     * This endpoint updates customer information on an open invoice and returns the updated
     * invoice. If you would like to preview changes that will be applied, use the
     * `/invoices/{uid}/customer_information/preview.json` endpoint before. The endpoint doesn't
     * accept a request body. Customer information differences are calculated on the application
     * side.
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> updateCustomerInformationAsync(
            final String uid) {
        try { 
            return prepareUpdateCustomerInformationRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for updateCustomerInformation.
     */
    private ApiCall<Invoice, ApiException> prepareUpdateCustomerInformationRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/customer_information.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint allows you to issue an invoice that is in "pending" status. For example, you
     * can issue an invoice that was created when allocating new quantity on a component and using
     * "accrue charges" option. You cannot issue a pending child invoice that was created for a
     * member subscription in a group. For Remittance subscriptions, the invoice will go into "open"
     * status and payment won't be attempted. The value for `on_failed_payment` would be rejected if
     * sent. Any prepayments or service credits that exist on subscription will be automatically
     * applied. Additionally, if setting is on, an email will be sent for issued invoice. For
     * Automatic subscriptions, prepayments and service credits will apply to the invoice and before
     * payment is attempted. On successful payment, the invoice will go into "paid" status and email
     * will be sent to the customer (if setting applies). When payment fails, the next event depends
     * on the `on_failed_payment` value: - `leave_open_invoice` - prepayments and credits applied to
     * invoice; invoice status set to "open"; email sent to the customer for the issued invoice (if
     * setting applies); payment failure recorded in the invoice history. This is the default
     * option. - `rollback_to_pending` - prepayments and credits not applied; invoice remains in
     * "pending" status; no email sent to the customer; payment failure recorded in the invoice
     * history. - `initiate_dunning` - prepayments and credits applied to the invoice; invoice
     * status set to "open"; email sent to the customer for the issued invoice (if setting applies);
     * payment failure recorded in the invoice history; subscription will most likely go into
     * "past_due" or "canceled" state (depending upon net terms and dunning settings).
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Invoice issueInvoice(
            final String uid,
            final IssueInvoiceRequest body) throws ApiException, IOException {
        return prepareIssueInvoiceRequest(uid, body).execute();
    }

    /**
     * This endpoint allows you to issue an invoice that is in "pending" status. For example, you
     * can issue an invoice that was created when allocating new quantity on a component and using
     * "accrue charges" option. You cannot issue a pending child invoice that was created for a
     * member subscription in a group. For Remittance subscriptions, the invoice will go into "open"
     * status and payment won't be attempted. The value for `on_failed_payment` would be rejected if
     * sent. Any prepayments or service credits that exist on subscription will be automatically
     * applied. Additionally, if setting is on, an email will be sent for issued invoice. For
     * Automatic subscriptions, prepayments and service credits will apply to the invoice and before
     * payment is attempted. On successful payment, the invoice will go into "paid" status and email
     * will be sent to the customer (if setting applies). When payment fails, the next event depends
     * on the `on_failed_payment` value: - `leave_open_invoice` - prepayments and credits applied to
     * invoice; invoice status set to "open"; email sent to the customer for the issued invoice (if
     * setting applies); payment failure recorded in the invoice history. This is the default
     * option. - `rollback_to_pending` - prepayments and credits not applied; invoice remains in
     * "pending" status; no email sent to the customer; payment failure recorded in the invoice
     * history. - `initiate_dunning` - prepayments and credits applied to the invoice; invoice
     * status set to "open"; email sent to the customer for the issued invoice (if setting applies);
     * payment failure recorded in the invoice history; subscription will most likely go into
     * "past_due" or "canceled" state (depending upon net terms and dunning settings).
     * @param  uid  Required parameter: The unique identifier for the invoice, this does not refer
     *         to the public facing invoice number.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Invoice response from the API call
     */
    public CompletableFuture<Invoice> issueInvoiceAsync(
            final String uid,
            final IssueInvoiceRequest body) {
        try { 
            return prepareIssueInvoiceRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issueInvoice.
     */
    private ApiCall<Invoice, ApiException> prepareIssueInvoiceRequest(
            final String uid,
            final IssueInvoiceRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Invoice, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/invoices/{uid}/issue.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Invoice.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}