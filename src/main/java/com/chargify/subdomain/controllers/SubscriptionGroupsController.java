/*
 * MaxioAdvancedBillingFormerlyChargifyAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.chargify.subdomain.controllers;

import com.chargify.subdomain.ApiHelper;
import com.chargify.subdomain.Server;
import com.chargify.subdomain.exceptions.ApiException;
import com.chargify.subdomain.exceptions.ErrorListResponseException;
import com.chargify.subdomain.exceptions.SubscriptionGroupsJson422Error2Exception;
import com.chargify.subdomain.exceptions.SubscriptionGroupsJson422ErrorException;
import com.chargify.subdomain.exceptions.SubscriptionGroupsSignupJson422ErrorException;
import com.chargify.subdomain.http.request.HttpMethod;
import com.chargify.subdomain.models.AddSubscriptionToAGroup;
import com.chargify.subdomain.models.CreateSubscriptionGroupRequest;
import com.chargify.subdomain.models.DeleteSubscriptionGroupResponse;
import com.chargify.subdomain.models.FullSubscriptionGroupResponse;
import com.chargify.subdomain.models.ListSubscriptionGroupsResponse;
import com.chargify.subdomain.models.SubscriptionGroupResponse;
import com.chargify.subdomain.models.SubscriptionGroupSignupRequest;
import com.chargify.subdomain.models.SubscriptionGroupSignupResponse;
import com.chargify.subdomain.models.UpdateSubscriptionGroupRequest;
import com.fasterxml.jackson.core.JsonProcessingException;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class SubscriptionGroupsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public SubscriptionGroupsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Create multiple subscriptions at once under the same customer and consolidate them into a
     * subscription group. You must provide one and only one of the
     * `payer_id`/`payer_reference`/`payer_attributes` for the customer attached to the group. You
     * must provide one and only one of the
     * `payment_profile_id`/`credit_card_attributes`/`bank_account_attributes` for the payment
     * profile attached to the group. Only one of the `subscriptions` can have `"primary": true`
     * attribute set. When passing product to a subscription you can use either `product_id` or
     * `product_handle` or `offer_id`. You can also use `custom_price` instead.
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupSignupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SubscriptionGroupSignupResponse signupWithSubscriptionGroup(
            final SubscriptionGroupSignupRequest body) throws ApiException, IOException {
        return prepareSignupWithSubscriptionGroupRequest(body).execute();
    }

    /**
     * Create multiple subscriptions at once under the same customer and consolidate them into a
     * subscription group. You must provide one and only one of the
     * `payer_id`/`payer_reference`/`payer_attributes` for the customer attached to the group. You
     * must provide one and only one of the
     * `payment_profile_id`/`credit_card_attributes`/`bank_account_attributes` for the payment
     * profile attached to the group. Only one of the `subscriptions` can have `"primary": true`
     * attribute set. When passing product to a subscription you can use either `product_id` or
     * `product_handle` or `offer_id`. You can also use `custom_price` instead.
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupSignupResponse response from the API call
     */
    public CompletableFuture<SubscriptionGroupSignupResponse> signupWithSubscriptionGroupAsync(
            final SubscriptionGroupSignupRequest body) {
        try { 
            return prepareSignupWithSubscriptionGroupRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for signupWithSubscriptionGroup.
     */
    private ApiCall<SubscriptionGroupSignupResponse, ApiException> prepareSignupWithSubscriptionGroupRequest(
            final SubscriptionGroupSignupRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SubscriptionGroupSignupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups/signup.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionGroupSignupResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new SubscriptionGroupsSignupJson422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a subscription group with given members.
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SubscriptionGroupResponse createSubscriptionGroup(
            final CreateSubscriptionGroupRequest body) throws ApiException, IOException {
        return prepareCreateSubscriptionGroupRequest(body).execute();
    }

    /**
     * Creates a subscription group with given members.
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<SubscriptionGroupResponse> createSubscriptionGroupAsync(
            final CreateSubscriptionGroupRequest body) {
        try { 
            return prepareCreateSubscriptionGroupRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for createSubscriptionGroup.
     */
    private ApiCall<SubscriptionGroupResponse, ApiException> prepareCreateSubscriptionGroupRequest(
            final CreateSubscriptionGroupRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionGroupResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new SubscriptionGroupsJson422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns an array of subscription groups for the site. The response is paginated and will
     * return a `meta` key with pagination information. #### Account Balance Information Account
     * balance information for the subscription groups is not returned by default. If this
     * information is desired, the `include[]=account_balances` parameter must be provided with the
     * request.
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  include  Optional parameter: Example:
     * @return    Returns the ListSubscriptionGroupsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ListSubscriptionGroupsResponse listSubscriptionGroups(
            final Integer page,
            final Integer perPage,
            final String include) throws ApiException, IOException {
        return prepareListSubscriptionGroupsRequest(page, perPage, include).execute();
    }

    /**
     * Returns an array of subscription groups for the site. The response is paginated and will
     * return a `meta` key with pagination information. #### Account Balance Information Account
     * balance information for the subscription groups is not returned by default. If this
     * information is desired, the `include[]=account_balances` parameter must be provided with the
     * request.
     * @param  page  Optional parameter: Result records are organized in pages. By default, the
     *         first page of results is displayed. The page parameter specifies a page number of
     *         results to fetch. You can start navigating through the pages to consume the results.
     *         You do this by passing in a page parameter. Retrieve the next page by adding ?page=2
     *         to the query string. If there are no results to return, then an empty result set will
     *         be returned. Use in query `page=1`.
     * @param  perPage  Optional parameter: This parameter indicates how many records to fetch in
     *         each request. Default value is 20. The maximum allowed values is 200; any per_page
     *         value over 200 will be changed to 200. Use in query `per_page=200`.
     * @param  include  Optional parameter: Example:
     * @return    Returns the ListSubscriptionGroupsResponse response from the API call
     */
    public CompletableFuture<ListSubscriptionGroupsResponse> listSubscriptionGroupsAsync(
            final Integer page,
            final Integer perPage,
            final String include) {
        try { 
            return prepareListSubscriptionGroupsRequest(page, perPage, include).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for listSubscriptionGroups.
     */
    private ApiCall<ListSubscriptionGroupsResponse, ApiException> prepareListSubscriptionGroupsRequest(
            final Integer page,
            final Integer perPage,
            final String include) throws IOException {
        return new ApiCall.Builder<ListSubscriptionGroupsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups.json")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 20).isRequired(false))
                        .queryParam(param -> param.key("include")
                                .value(include).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ListSubscriptionGroupsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to find subscription group details. #### Current Billing Amount in Cents
     * Current billing amount for the subscription group is not returned by default. If this
     * information is desired, the `include[]=current_billing_amount_in_cents` parameter must be
     * provided with the request.
     * @param  uid  Required parameter: The uid of the subscription group
     * @return    Returns the FullSubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public FullSubscriptionGroupResponse readSubscriptionGroup(
            final String uid) throws ApiException, IOException {
        return prepareReadSubscriptionGroupRequest(uid).execute();
    }

    /**
     * Use this endpoint to find subscription group details. #### Current Billing Amount in Cents
     * Current billing amount for the subscription group is not returned by default. If this
     * information is desired, the `include[]=current_billing_amount_in_cents` parameter must be
     * provided with the request.
     * @param  uid  Required parameter: The uid of the subscription group
     * @return    Returns the FullSubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<FullSubscriptionGroupResponse> readSubscriptionGroupAsync(
            final String uid) {
        try { 
            return prepareReadSubscriptionGroupRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for readSubscriptionGroup.
     */
    private ApiCall<FullSubscriptionGroupResponse, ApiException> prepareReadSubscriptionGroupRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<FullSubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups/{uid}.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, FullSubscriptionGroupResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to update subscription group members. `"member_ids": []` should contain an
     * array of both subscription IDs to set as group members and subscription IDs already present
     * in the groups. Not including them will result in removing them from subscription group. To
     * clean up members, just leave the array empty.
     * @param  uid  Required parameter: The uid of the subscription group
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SubscriptionGroupResponse updateSubscriptionGroupMembers(
            final String uid,
            final UpdateSubscriptionGroupRequest body) throws ApiException, IOException {
        return prepareUpdateSubscriptionGroupMembersRequest(uid, body).execute();
    }

    /**
     * Use this endpoint to update subscription group members. `"member_ids": []` should contain an
     * array of both subscription IDs to set as group members and subscription IDs already present
     * in the groups. Not including them will result in removing them from subscription group. To
     * clean up members, just leave the array empty.
     * @param  uid  Required parameter: The uid of the subscription group
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<SubscriptionGroupResponse> updateSubscriptionGroupMembersAsync(
            final String uid,
            final UpdateSubscriptionGroupRequest body) {
        try { 
            return prepareUpdateSubscriptionGroupMembersRequest(uid, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for updateSubscriptionGroupMembers.
     */
    private ApiCall<SubscriptionGroupResponse, ApiException> prepareUpdateSubscriptionGroupMembersRequest(
            final String uid,
            final UpdateSubscriptionGroupRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups/{uid}.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionGroupResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new SubscriptionGroupsJson422Error2Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to delete subscription group. Only groups without members can be deleted.
     * @param  uid  Required parameter: The uid of the subscription group
     * @return    Returns the DeleteSubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DeleteSubscriptionGroupResponse deleteSubscriptionGroup(
            final String uid) throws ApiException, IOException {
        return prepareDeleteSubscriptionGroupRequest(uid).execute();
    }

    /**
     * Use this endpoint to delete subscription group. Only groups without members can be deleted.
     * @param  uid  Required parameter: The uid of the subscription group
     * @return    Returns the DeleteSubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<DeleteSubscriptionGroupResponse> deleteSubscriptionGroupAsync(
            final String uid) {
        try { 
            return prepareDeleteSubscriptionGroupRequest(uid).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for deleteSubscriptionGroup.
     */
    private ApiCall<DeleteSubscriptionGroupResponse, ApiException> prepareDeleteSubscriptionGroupRequest(
            final String uid) throws IOException {
        return new ApiCall.Builder<DeleteSubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups/{uid}.json")
                        .templateParam(param -> param.key("uid").value(uid)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, DeleteSubscriptionGroupResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to find subscription group associated with subscription. If the
     * subscription is not in a group endpoint will return 404 code.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription associated
     *         with the subscription group
     * @return    Returns the FullSubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public FullSubscriptionGroupResponse readSubscriptionGroupBySubscriptionId(
            final String subscriptionId) throws ApiException, IOException {
        return prepareReadSubscriptionGroupBySubscriptionIdRequest(subscriptionId).execute();
    }

    /**
     * Use this endpoint to find subscription group associated with subscription. If the
     * subscription is not in a group endpoint will return 404 code.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription associated
     *         with the subscription group
     * @return    Returns the FullSubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<FullSubscriptionGroupResponse> readSubscriptionGroupBySubscriptionIdAsync(
            final String subscriptionId) {
        try { 
            return prepareReadSubscriptionGroupBySubscriptionIdRequest(subscriptionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for readSubscriptionGroupBySubscriptionId.
     */
    private ApiCall<FullSubscriptionGroupResponse, ApiException> prepareReadSubscriptionGroupBySubscriptionIdRequest(
            final String subscriptionId) throws IOException {
        return new ApiCall.Builder<FullSubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscription_groups/lookup.json")
                        .queryParam(param -> param.key("subscription_id")
                                .value(subscriptionId))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, FullSubscriptionGroupResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * For sites making use of the [Relationship
     * Billing](https://chargify.zendesk.com/hc/en-us/articles/4407737494171) and [Customer
     * Hierarchy](https://chargify.zendesk.com/hc/en-us/articles/4407746683291) features, it is
     * possible to add existing subscriptions to subscription groups. Passing `group` parameters
     * with a `target` containing a `type` and optional `id` is all that's needed. When the `target`
     * parameter specifies a `"customer"` or `"subscription"` that is already part of a hierarchy,
     * the subscription will become a member of the customer's subscription group. If the target
     * customer or subscription is not part of a subscription group, a new group will be created and
     * the subscription will become part of the group with the specified target customer set as the
     * responsible payer for the group's subscriptions. **Please Note:** In order to add an existing
     * subscription to a subscription group, it must belong to either the same customer record as
     * the target, or be within the same customer hierarchy. Rather than specifying a customer, the
     * `target` parameter could instead simply have a value of * `"self"` which indicates the
     * subscription will be paid for not by some other customer, but by the subscribing customer, *
     * `"parent"` which indicates the subscription will be paid for by the subscribing customer's
     * parent within a customer hierarchy, or * `"eldest"` which indicates the subscription will be
     * paid for by the root-level customer in the subscribing customer's hierarchy. To create a new
     * subscription into a subscription group, please reference the following: [Create Subscription
     * in a Subscription
     * Group](https://developers.chargify.com/docs/api-docs/d571659cf0f24-create-subscription#subscription-in-a-subscription-group).
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SubscriptionGroupResponse createSubscriptionGroupHierarchy(
            final String subscriptionId,
            final AddSubscriptionToAGroup body) throws ApiException, IOException {
        return prepareCreateSubscriptionGroupHierarchyRequest(subscriptionId, body).execute();
    }

    /**
     * For sites making use of the [Relationship
     * Billing](https://chargify.zendesk.com/hc/en-us/articles/4407737494171) and [Customer
     * Hierarchy](https://chargify.zendesk.com/hc/en-us/articles/4407746683291) features, it is
     * possible to add existing subscriptions to subscription groups. Passing `group` parameters
     * with a `target` containing a `type` and optional `id` is all that's needed. When the `target`
     * parameter specifies a `"customer"` or `"subscription"` that is already part of a hierarchy,
     * the subscription will become a member of the customer's subscription group. If the target
     * customer or subscription is not part of a subscription group, a new group will be created and
     * the subscription will become part of the group with the specified target customer set as the
     * responsible payer for the group's subscriptions. **Please Note:** In order to add an existing
     * subscription to a subscription group, it must belong to either the same customer record as
     * the target, or be within the same customer hierarchy. Rather than specifying a customer, the
     * `target` parameter could instead simply have a value of * `"self"` which indicates the
     * subscription will be paid for not by some other customer, but by the subscribing customer, *
     * `"parent"` which indicates the subscription will be paid for by the subscribing customer's
     * parent within a customer hierarchy, or * `"eldest"` which indicates the subscription will be
     * paid for by the root-level customer in the subscribing customer's hierarchy. To create a new
     * subscription into a subscription group, please reference the following: [Create Subscription
     * in a Subscription
     * Group](https://developers.chargify.com/docs/api-docs/d571659cf0f24-create-subscription#subscription-in-a-subscription-group).
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @param  body  Optional parameter: Example:
     * @return    Returns the SubscriptionGroupResponse response from the API call
     */
    public CompletableFuture<SubscriptionGroupResponse> createSubscriptionGroupHierarchyAsync(
            final String subscriptionId,
            final AddSubscriptionToAGroup body) {
        try { 
            return prepareCreateSubscriptionGroupHierarchyRequest(subscriptionId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for createSubscriptionGroupHierarchy.
     */
    private ApiCall<SubscriptionGroupResponse, ApiException> prepareCreateSubscriptionGroupHierarchyRequest(
            final String subscriptionId,
            final AddSubscriptionToAGroup body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SubscriptionGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscriptions/{subscription_id}/group.json")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("subscription_id").value(subscriptionId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionGroupResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * For sites making use of the [Relationship
     * Billing](https://chargify.zendesk.com/hc/en-us/articles/4407737494171) and [Customer
     * Hierarchy](https://chargify.zendesk.com/hc/en-us/articles/4407746683291) features, it is
     * possible to remove existing subscription from subscription group.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void removeSubscriptionFromGroup(
            final String subscriptionId) throws ApiException, IOException {
        prepareRemoveSubscriptionFromGroupRequest(subscriptionId).execute();
    }

    /**
     * For sites making use of the [Relationship
     * Billing](https://chargify.zendesk.com/hc/en-us/articles/4407737494171) and [Customer
     * Hierarchy](https://chargify.zendesk.com/hc/en-us/articles/4407746683291) features, it is
     * possible to remove existing subscription from subscription group.
     * @param  subscriptionId  Required parameter: The Chargify id of the subscription
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> removeSubscriptionFromGroupAsync(
            final String subscriptionId) {
        try { 
            return prepareRemoveSubscriptionFromGroupRequest(subscriptionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for removeSubscriptionFromGroup.
     */
    private ApiCall<Void, ApiException> prepareRemoveSubscriptionFromGroupRequest(
            final String subscriptionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/subscriptions/{subscription_id}/group.json")
                        .templateParam(param -> param.key("subscription_id").value(subscriptionId)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("Unprocessable Entity (WebDAV)",
                                (reason, context) -> new ErrorListResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}